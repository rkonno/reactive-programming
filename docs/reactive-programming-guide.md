# リアクティブプログラミング入門

## リアクティブプログラミングとは
リアクティブプログラミング（Reactive Programming）とは、

> 計算機においては、リアクティブプログラミングはデータフローの変更と伝搬を中心としたプログラミングパラダイム  

である。

オブジェクト指向などと同様に一つのパラダイムと捉えるのが良い。言語やライブラリ、フレームワークに縛られるのではなく、スタイルのようなものであり、ふわっとしたもの。
では、データフローと変更の伝搬を中心とする、とはなにか。

## リアクティブプログラミングの特徴
リアクティブプログラミングは従来の命令形プログラミング（Imperative Progreamming）と対比していると考えるとわかりやすい。

通常のプログラミングでは、変数間の関係を記述したあとに変数Aと変数Bの変更を伝搬させることで変数Cの値を更新する。

```
A = 2
B = 3
C = (A + 1) * (B - 1)
```
一方、リアクティブプログラミングでは、①データフローの定義と②変更の伝搬の２つの手段がある。

多くの場合、プログラマーが書くのは①だけで、②の変更の伝搬についてはフレームワークやライブラリが面倒を見てくれる。

ここで重要なのは、先に満たすべき関係を記述しておけば、跡は変更がある度に伝搬させることで正しい結果が得られるということ。命令形プログラミングでは、その伝播に担当する操作を書き下ろす必要があったが、リアクティブプログラミングではその必要はない。

モバイルアプリではネットワーク通信、ユーザーの入力、位置情報の変更などといった多様な入力がされる。従来の命令形プログラミングで、それらを組み合わせて望む処理を行うには、多くの状態変数の導入が必要だった。

一方、リアクティブプログラミングを行うことで、状態変数の数を減らし、よりバグの混入しにくいプログラムを作成できる。

## リアクティブエクステンション（Reactive Extention、Rx）

リアクティブエクステンションあるいは、ReactiveX、Rxと呼ばれるライブラリは、先述のリアクティブプログラミングを実現するためのライブラリである。

> ReactiveXは、観測可能なシーケンス（Observable sequences）を使うことで非同期でイベントベースのプログラムを合成（compose）するライブラリ  

出てくる概念について、一つ一つ確認しながら、Rxの詳細について説明していく。

重要用語は以下の３つ。

* 観測可能なシーケンス（Observable Sequences）
* 非同期でイベントベースのプログラム
* 合成（compose）

#### 非同期でイベントベースなプログラム

２つめの非同期でイベントベースなプログラムというのは、Rxが対象としているプログラムを示す。例えば、ネットワーク通信を行い、そのレスポンスを待つのは非同期なプログラムになるし、画面のタップに応じて何かを行うのはイベントベースのプログラムになる。

私たちが開発しているモバイルアプリは、まさにこのようなプログラムで構成されているので、Rxがターゲットとしている領域であることがわかる。

逆に非同期でなかったり、イベントベースでないなら、無理にRxを使う必要はないとも言える。

#### 観測可能なシーケンス（Observable Sequences）

次に、観測可能なシーケンス（Observable Sequences）についてだが、Rxはオブザーバーパターンと呼ばれる、変数が発生する対象にオブザーバーを登録するデザインパターンをベースにしている。つまり、タップイベントであれば、タップが発生するボタンなどのUI部品にそのタップイベントを観測するオブザーバーを登録する。

さらに重要なことは、そのオブザーバーはただ一度のイベントを観測するのではなく、解除されるまでの間に発生するイベントすべてをシーケンス（sequence）として観測する。

イベントをシーケンスとして扱うことがRxの最も大きな特徴と言っても良い。これによって、後述するような様々な複雑な処理を、私たちにとって馴染みがあるリスト処理として扱うことが可能になる。

では、一度しか発生しないネットワーク通信のような非同期処理はどのようになるか。こちらもイベント要素が１つのシーケンスとして扱うことができる。イベントを排出（emit）するもととなるものを、RxではObservableと呼ぶ。そして、そのイベントを観測する主体をObserverと言う。

アプリ開発でRxを使う際には、何らかのイベントや非同期処理を表すObservableをまず作り、それを消費するタイミングでObserverが観測を始める（購読する subscribe と言う）という流れになる。

**Observableの購読**
```
def tapObservable = ... // タップイベントを表すObserver
def myOnNext = ... //イベントを観測したときに行う処理
tapObservable.subscribe(myOnNext) // 観測開始
```

一般的にObserverを作成してsubscribeメソッドの引数にわたすこともできるが、ラムダ式や無名関数を扱える言語では、Observerの対応するメソッドの実装をそのままsubscribeの引数に渡してしまうことが多い。

* onNext
	* Observableからイベントが排出される度に呼ばれるメソッド
	* メソッドの引数には排出されたいイベントが渡される
* onError
	* Observableが何らかのエラーを起こしたときに呼ばれるメソッド
	* これ以降にonNextやonCompletedが呼ばれることはない
	* 引数には何らかのエラーの原因が渡される
* onCompleted
	* 最後のonNextが呼ばれたあとに呼ばれるメソッド

これらを使った例は以下の通り。

**ネットワーク通信のObservable**
```
def networkObservable = ... // ネットワーク通信を表すObservable
networkObservable.subscribe(
    { it -> show(it.message) }, // イベントを受け取ったときに呼ばれる処理
    { err -> showErr(err.message) }, // エラーが起きたときに呼ばれる処理
    { show("completed!") }) // 完了したときに呼ばれる処理
```

これらの onNext、onError、onCompletedはObservableの契約に従う。ObservableはonNextを0もしくは1回以上呼び、onErrorもしくはonCompletedのどちらかを呼ぶかもしれません。その場合、これ以上のメソッド呼び出しはない。

一つ大事なことは、Observableは基本的に購読されるまでイベントを排出し始めないということ。

初学者が陥りがちな罠として、Observableを作ったらイベントの排出が始まるのではないか、と勘違いしてしまうこと。実際には購読が行われるまでイベントの排出がされないことがほとんど。

たとえば、特定のネットワーク通信を表すObservableを作っただけでは通信は発生しない。その代わり、購読されたタイミングで初めて通信が発生し、レスポンスが返ってくると、その内容がイベントとしてSubscriberに伝わる。

**Observableを購読するタイミング**
```
def networkObservable = ... // ネットワーク通信を表すObservable
... // 他の処理 この時点ではネットワーク通信はまだ発生していない
networkObservable.subscribe({ it -> show(it.message) }) // 通信結果を表示
```

これと並んで、初学者が陥りがちな罠は、「同じObservableを購読したときに排出されるイベントのシーケンスは共通である」という勘違い。実際には、Observableが受け取るイベントシーケンスは独立。

同じObservableインスタンスを2つのObserverが購読している。このObservableは1秒ごとに１，２，３，４，５と排出する。このとき、2つのObserverのログ出力は、2つ目のObserverの購読は遅れいている。しかし、どちらとも出力は１，２，３，４，５となる。なぜなら、Observableは、Observerごとに別々のイベントシーケンスを排出するからだ。

もし、通信を行うObservableであれば、購読するごとに通信が発生するので注意が必要。

**同じObservableを2回購読した場合**
```
// 1秒ごとに5つのイベントが排出される
def myObservable = Observable.interval(1, TimeUnit.SECONDS).take(5)
myObservable.subscribe({ it -> log("First observer: $it) })
... // 1秒以上かかる何らかの処理
myObservable.subscribe({ it -> log("Second observer: $it) })
```

#### 合成（compose）

最後に、合成（compose）について。Rxでは、イベントをシーケンスとして扱うだけでなく、シーケンスを変形して新しいシーケンスを生成したり、複数のシーケンスから1つのシーケンスを生成することができる。このとき、一連のイベントをシーケンスとして扱っていたことが意味を持つ。私たちがコレクションに対して行うのと似たような操作をできるようになる。

実際に、Rxを従来のリスト操作におけるIterableと比較してプル型ではなくプッシュ型という説明がされることもある。確かに、リスト操作との共通点は多いが、そこにはこだわらず、オペレータと共通点があるという程度に捉えておくと良い。
オペレータの例を見てみる。

```
Observable.just(1, 2, 3, 4)
          .filter({ x -> x % 2 == 0 })
          .map({ x -> x * x })
          .subscribe({ x -> print(x) }) // [4, 16] が表示される
```

この例では、シーケンス1，2，3，4を生成し、最初の**filter**メソッドを適用することで偶数のみのシーケンスを生成している。さらに**map**メソッドを適用し、各要素を二乗している。したがって、最終的に出力されるのは4，16となる。**filter**、**map**などのコレクション操作でお馴染みの演算を行うことができる。このようにイベントのシーケンスを変形していく演算をRxでは、**オペレータ（Operator）**と呼び、これも特徴となっている。

このオペレーターを使うメリットの1つは、一時変数や状態変数を持つ必要がなくなること。たとえば、タップイベントを検出したいとする。Rxを使わない実装は、タップイベントを観測して、直前のタップとの時間差を計算する。一定時間以内だったらダブルタップと判断できる。

一方、Rxではシングルタップのイベントシーケンスを生成し、それをもとにダブルタップのイベントシーケンスを作成する。そのようなイベントシーケンス（Observable）ができれば、あとはそれを購読するだけ。

では、どうすればダブルタップObservableは作れるか。実はRxのオペレータには、一定時間かつ連続した2つのイベントを別のイベントに変換するものがある。（Bufferというイベントがそれ）したがって、そのオペレータを適用すれば、ダブルタップのイベントシーケンスを作成できる。

このとき大事なことは、状態変数（Rxを使わない例では直前のタップ時刻）を必要としないということ。もちろん、Rx内部ではそのような変数を持っていると考えられるが、私たちはそのような細かい実装に頭を悩ませずにオペレータを適切に適用するだけでのぞみのObservableを作れる。

* Observable
	* イベントを排出するもの
	* UI部品のタップイベントだったり、ネットワーク通信だったりする
* 購読（subscribe）
	* Observableの観測を開始すること
* Observer
	* Observableを購読する主体
	* 文脈によっては、Subscriber、Reactorと呼ばれる
	* 排出されるイベントや完了／エラー通知に対応するObserverのメソッドが呼ばれる
	* 無名関数やラムダ式が使える言語の場合は、subscribeメソッドの引数に渡されるラムダ式で表されることも
* Operator
	* Observableから別のObservableを作成する関数
	* 多くの場合は関数を引数に取る高階関数

### その他のRxの概念

1. Subscription
2. Hot／Cold Observable
3. Subject
4. Scheduler

#### Subscription

最初にSubscriptionという概念について。RxSwift等では、Observableの**subscribe**メソッドの戻り値であり、観測している状態を表す。もし、観測が不要になったらRxSwiftでは、**dispose**メソッドを呼ぶことで、Observableにイベント排出が不要になったことを知らせる。

**Subscriptionの例**
```
def subscription = myObservable.subscribe({ it -> println(it) })
subscription.dispose() // これ以降はonNextが呼ばれないことが保証された
```

このメソッドが重要なのは、リソースの開放に深く関わるからである。モバイルアプリではメモリの制約が強く、不要になったリソースを開放せずに保持し続けてメモリリークにつながると、アプリのクラッシュをひこ起こす可能性がある。

実際の開発では、必ず不要になったタイミングで**dispose**を呼ぶようにする。

#### Hot Observable
次に、**Hot Observable** について。

Observableは一般に観測するまでイベントを排出しない。また、購読するObserverごとに独立したイベントを排出する。このようなObservableは**Cold Observable**と呼ばれる。一方、Hot Observableは、作成されたタイミングでイベントの排出を開始する。そして、複数のObservableが同じHot Observableを観測した場合は、同じイベントが複数のObserverに対して排出される。したがって、Observerが作成されたタイミングとそれぞれのObserverが購読するタイミングによって受け取るイベントは異なることになる。

また言語によって、**Connectable Observable**と呼ばれるものがある。これは、**connect()**というメソッドが呼ばれて初めてイベントの排出を始めるHot Observableで、通常はConnectable Observableを使うことになる。RxSwiftもConnectable Observableをサポートしており、Cold Observableに対して**publish()**メソッドを呼ぶことにより、Connectable Observableに変換することが可能。

**Cionnecrtable Observableの例**
```
def connectable = Observable.just(1, 2, 3).publish()
connctable.subscribe({ it -> println("observer 1: $it") })
connctable.subscribe({ it -> println("observer 2: $it") })
// ここでは、またイベントが１つも排出されていない
connectable.connect()
// このときには、すでにすべての数字が排出されているので。
// observer 3は1つもイベントを観測しない
connctable.subscribe({ it -> println("observer 3: $it") })
```

Hot Observableは便利ですが、使い方には注意が必要。というのも、購読が実行されるタイミングによって予期しない行動をすることがあるからである。

#### Subject

Subjectは、一言で言えば「Observableであり、かつObserverであるもの」である。より詳しく言えば、「任意のObservableを購読し、排出されたイベントを排出するObservable」である。

**Subjectの例**
```
def subject = PublishSubject.create()
subject.subscribe({ it -> println("observer 1: $it") })
subject.onNext(1)
subject.subscribe({ it -> println("observer 2: $it") })
subject.onNext(2)
```

**PublishSubject**というSubjectの一種を使っている。これは、onNextが呼ばれると、即座に今購読しているObserverに対して受け取ったイベントをそのまま排出する。したがって、最初のObserverはイベントをすべて受け取るが、2つ目のObserverは2番目のイベントとしか受け取らない。

見てわかるように、SubjectはHot Observableである。したがって、**subscribe**と**onNext**のタイミングによって結果が変わることに注意すべき。Subjectはあまり使うべきではないという意見も多い。基本的には避けたほうが無難。まずは通常のオペレータや既存のライブラリで解決できないか検討し、どうしても難しそうなら使うようにするべき。

#### Scheduler

モバイルアプリ開発で非同期処理を行う際には、UIインタラクションを阻害しないように、メインスレッド（UIスレッド）ではなく別スレッドで非同期処理を行う必要がある。RxのオペレータのいくつかはSchedulerを引数にとり、適切なSchedulerを指定することで、操作を別スレッドで行うことができる。たとえば、以下の例だと、Observable内の処理及び**map**オペレータの操作を別スレッドで行い、最後にUIで表示するときにメインスレッドを使用している。

**Schedulerの例**
```
// デフォルトではsubscribeメソッドが呼ばれたスレッド（ここではメインスレッド）で実行される
Observable.range(1, 5)
          .subscribeOn(Schedulers.computation()) // このObserver処理はcomputationスケジューラで開始される
          .map({ i -> i * i })
          .observerOn(MainScheduler.instance) // 以降の処理はメインスレッドで行う
          .subscriber({ x -> show(x) })
```

こうすることで時間のかかる非同期処理は別スレッドで行い、UI操作を行う処理はメインスレッドで行う、といったことが簡単に切り替えられる。
